{
  "language": "Solidity",
  "sources": {
    "contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract AccessControl {\r\n    bytes32 public constant ADMIN_ROLE = 0x00;\r\n    \r\n    mapping(bytes32 => mapping(address => bool)) roles;\r\n    \r\n    event GrantRole(address account, bytes32 role);\r\n    event RevokeRole(address account, bytes32 role);\r\n    event RenounceRole(address account, bytes32 role);\r\n    \r\n    modifier onlyRole(bytes32 role) {\r\n        require(roles[role][msg.sender], \"AccessControl::Your role is not able to do this\");\r\n        _;\r\n    }\r\n    \r\n    function getAdminRole() public pure returns(bytes32) {\r\n        return ADMIN_ROLE;\r\n    }\r\n    \r\n    function hasRole(address _address, bytes32 _role) public view returns(bool) {\r\n        return roles[_role][_address];\r\n    }\r\n    \r\n    function grantRole(address _account, bytes32 _role) public onlyRole(getAdminRole()) {\r\n       _grantRole(_account, _role);\r\n    }\r\n    \r\n     function revokeRole(address _account, bytes32 _role) public onlyRole(getAdminRole()) {\r\n       _revokeRole(_account, _role);\r\n    }\r\n    \r\n    function renounceRole(address _account, bytes32 _role) public onlyRole(getAdminRole()) {\r\n        require(_account == msg.sender, \"AccessControl::You can only renounce roles for self\");\r\n        _revokeRole(msg.sender, _role);\r\n    }\r\n    \r\n    function _setupRole(address _account, bytes32 _role) internal {\r\n        _grantRole(_account, _role);\r\n    }\r\n    \r\n    function _grantRole(address _account, bytes32 _role) private {\r\n        require(!hasRole(_account, _role), \"AccessControl::User already granted for this role\");\r\n        roles[_role][_account] = true;\r\n        \r\n        emit GrantRole(_account, _role); \r\n    }\r\n    \r\n    function _revokeRole(address _account, bytes32 _role) private {\r\n        require(hasRole(_account, _role), \"AccessControl::User not granted for this role yet\");\r\n        roles[_role][_account] = false;\r\n        \r\n        emit RevokeRole(_account, _role); \r\n    }\r\n    \r\n    function _renounceRole(address _account, bytes32 _role) private {\r\n        require(hasRole(_account, _role), \"AccessControl::User not granted for this role yet\");\r\n        roles[_role][_account] = false;\r\n        \r\n        emit RenounceRole(_account, _role); \r\n    }\r\n}"
    },
    "contracts/tokens/Ruin.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../extensions/ERC20Capped.sol\";\r\nimport \"../access/AccessControl.sol\";\r\n\r\ncontract Ruin is ERC20Capped, AccessControl {\r\n    bytes32 constant public MINTER_ROLE = keccak256(abi.encodePacked(\"MINTER_ROLE\"));\r\n    bytes32 constant public BURNER_ROLE = keccak256(abi.encodePacked(\"BURNER_ROLE\"));\r\n    \r\n    constructor(\r\n        string memory _name, \r\n        string memory _symbol, \r\n        uint8 _decimals, \r\n        uint256 _cap\r\n    ) ERC20(_name, _symbol, _decimals) ERC20Capped(_cap) {\r\n        _setupRole(_msgSender(), ADMIN_ROLE);\r\n    }\r\n    \r\n    function burn(address _account, uint256 _amount) public onlyRole(BURNER_ROLE) {\r\n        _burn(_account, _amount);\r\n    }\r\n\r\n    function mint(address _account, uint256 _amount) public onlyRole(MINTER_ROLE) {\r\n        _mint(_account, _amount);\r\n    }\r\n\r\n    function isMinter(address _account) public view returns(bool) {\r\n        return hasRole(_account, MINTER_ROLE);\r\n    }\r\n\r\n    function isBurner(address _account) public view returns(bool) {\r\n        return hasRole(_account, BURNER_ROLE);\r\n    }\r\n}"
    },
    "contracts/extensions/ERC20Capped.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../tokens/ERC20.sol\";\r\n\r\nabstract contract ERC20Capped is ERC20 {\r\n    uint256 private immutable _cap;\r\n    \r\n    constructor(uint256 cap_) {\r\n        _cap = cap_;\r\n    }\r\n    \r\n    function cap() public view returns(uint256) {\r\n        return _cap;\r\n    }\r\n    \r\n    function _mint(address _account, uint256 _amount) internal override {\r\n        require(totalSupply() + _amount <= cap(), \"ERC20Capped::You mint exceeds your cap\");\r\n        super._mint(_account, _amount);\r\n    }\r\n}"
    },
    "contracts/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../interfaces/IERC20.sol\";\r\nimport \"../utils/Context.sol\";\r\n\r\ncontract ERC20 is IERC20, Context {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals = 18;\r\n\r\n    uint256 private _totalSupply;\r\n    \r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    mapping(address => uint256) private _balances;\r\n    \r\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = decimals_;\r\n    }\r\n     \r\n    function name() external view returns(string memory) {\r\n        return _name;\r\n    }\r\n    \r\n    function symbol() external view returns(string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() external view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n    \r\n    function totalSupply() public view override returns(uint256) {\r\n        return _totalSupply;\r\n    }\r\n     \r\n     \r\n    function balanceOf(address account) external view override returns (uint256) {\r\n         return _balances[account];\r\n    }\r\n\r\n   \r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n \r\n    function allowance(address owner, address spender) external view override returns (uint256) {\r\n        return _allowances[owner][spender];   \r\n    }\r\n\r\n\r\n    function approve(address spender, uint256 amount) external override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external override returns (bool) {\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"Ruin::Transfer amount exceeds allowance\");\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    function _transfer(\r\n        address _sender, \r\n        address _recipient, \r\n        uint256 _amount\r\n    ) private {\r\n        require(_recipient != address(0), \"Ruin::Address of recipient is ilegal\");\r\n        require(_sender != address(0), \"Ruin::Address of sender is ilegal\");\r\n        require(_amount <= _balances[_sender], \"Ruin::Transfer amount exceeds account balance\");\r\n        \r\n        _balances[_sender] -= _amount;\r\n        _balances[_recipient] += _amount;\r\n        \r\n        emit Transfer(_sender, _recipient, _amount);\r\n    }\r\n    \r\n    function _approve(\r\n        address _approver, \r\n        address _spender, \r\n        uint256 _amount\r\n    ) private {\r\n        require(_approver != address(0), \"Ruin::Address of approver is ilegal\");\r\n        require(_spender != address(0), \"Ruin::Address of spender is ilegal\");\r\n        \r\n        _allowances[_approver][_spender] = _amount;\r\n        \r\n        emit Approval(_approver, _spender, _amount);\r\n    }\r\n    \r\n    function _mint(address _receiver, uint256 _amount) internal virtual {\r\n        require(_receiver != address(0), \"Ruin::Address of receiver is ilegal\");\r\n        \r\n        _totalSupply += _amount;\r\n        _balances[_receiver] += _amount;\r\n        \r\n        emit Transfer(address(0), _receiver, _amount);\r\n    }\r\n    \r\n    function _burn(address _account, uint256 _amount) internal {\r\n        require(_account != address(0), \"Ruin::Address is ilegal\"); \r\n        require(_balances[_account] >= _amount, \"Ruin::Burning amount exceeds account balance\");\r\n        \r\n        _totalSupply -= _amount;\r\n        _balances[_account] -= _amount;\r\n        \r\n        emit Transfer(_account, address(0), _amount);\r\n    }\r\n\r\n}"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"
    },
    "contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ncontract Context {\r\n    function _msgSender() internal view returns(address) {\r\n        return msg.sender;\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}