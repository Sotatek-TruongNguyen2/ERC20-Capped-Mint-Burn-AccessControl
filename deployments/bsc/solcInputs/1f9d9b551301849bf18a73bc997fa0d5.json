{
  "language": "Solidity",
  "sources": {
    "contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract AccessControl {\n    bytes32 public constant ADMIN_ROLE = 0x00;\n    \n    mapping(bytes32 => mapping(address => bool)) roles;\n    \n    event GrantRole(address account, bytes32 role);\n    event RevokeRole(address account, bytes32 role);\n    event RenounceRole(address account, bytes32 role);\n    \n    modifier onlyRole(bytes32 role) {\n        require(roles[role][msg.sender], \"AccessControl::Your role is not able to do this\");\n        _;\n    }\n    \n    function getAdminRole() public pure returns(bytes32) {\n        return ADMIN_ROLE;\n    }\n    \n    function hasRole(address _address, bytes32 _role) public view returns(bool) {\n        return roles[_role][_address];\n    }\n    \n    function grantRole(address _account, bytes32 _role) public onlyRole(getAdminRole()) {\n       _grantRole(_account, _role);\n    }\n    \n     function revokeRole(address _account, bytes32 _role) public onlyRole(getAdminRole()) {\n       _revokeRole(_account, _role);\n    }\n    \n    function renounceRole(address _account, bytes32 _role) public {\n        require(_account == msg.sender, \"AccessControl::You can only renounce roles for self\");\n        _revokeRole(msg.sender, _role);\n    }\n    \n    function _setupRole(address _account, bytes32 _role) internal {\n        _grantRole(_account, _role);\n    }\n    \n    function _grantRole(address _account, bytes32 _role) private {\n        require(!hasRole(_account, _role), \"AccessControl::User already granted for this role\");\n        roles[_role][_account] = true;\n        \n        emit GrantRole(_account, _role); \n    }\n    \n    function _revokeRole(address _account, bytes32 _role) private {\n        require(hasRole(_account, _role), \"AccessControl::User not granted for this role yet\");\n        roles[_role][_account] = false;\n        \n        emit RevokeRole(_account, _role); \n    }\n    \n    // function _renounceRole(address _account, bytes32 _role) private {\n    //     require(hasRole(_account, _role), \"AccessControl::User not granted for this role yet\");\n    //     roles[_role][_account] = false;\n        \n    //     emit RenounceRole(_account, _role); \n    // }\n}"
    },
    "contracts/tokens/Ruin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../extensions/ERC20Pausable.sol\";\nimport \"../extensions/ERC20Capped.sol\";\nimport \"../access/AccessControl.sol\";\n\ncontract Ruin is AccessControl, ERC20Pausable, ERC20Capped {\n    bytes32 constant public MINTER_ROLE = keccak256(abi.encodePacked(\"MINTER_ROLE\"));\n    bytes32 constant public BURNER_ROLE = keccak256(abi.encodePacked(\"BURNER_ROLE\"));\n    \n    constructor(\n        string memory _name, \n        string memory _symbol, \n        uint8 _decimals, \n        uint256 _cap\n    ) ERC20(_name, _symbol, _decimals) ERC20Capped(_cap) {\n        _setupRole(_msgSender(), ADMIN_ROLE);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override(ERC20, ERC20Pausable) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    function _mint(address _account, uint256 _amount) internal override(ERC20, ERC20Capped) {\n        super._mint(_account, _amount);\n    }\n    \n    function burn(address _account, uint256 _amount) public onlyRole(BURNER_ROLE) {\n        _burn(_account, _amount);\n    }\n\n    function mint(address _account, uint256 _amount) public onlyRole(MINTER_ROLE) {\n        super._mint(_account, _amount);\n    }\n\n    function isMinter(address _account) public view returns(bool) {\n        return hasRole(_account, MINTER_ROLE);\n    }\n\n    function isBurner(address _account) public view returns(bool) {\n        return hasRole(_account, BURNER_ROLE);\n    }\n\n    function pause() public whenNotPaused onlyRole(ADMIN_ROLE) {\n        _pause();\n    }\n\n    function unpause() public whenPaused onlyRole(ADMIN_ROLE) {\n        _unpause();\n    }\n}"
    },
    "contracts/extensions/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../tokens/ERC20.sol\";\nimport \"../utils/Pausable.sol\";\n\nabstract contract ERC20Pausable is ERC20, Pausable {\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}"
    },
    "contracts/extensions/ERC20Capped.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../tokens/ERC20.sol\";\n\nabstract contract ERC20Capped is ERC20 {\n    uint256 private immutable _cap;\n    \n    constructor(uint256 cap_) {\n        _cap = cap_;\n    }\n    \n    function cap() public view returns(uint256) {\n        return _cap;\n    }\n    \n    function _mint(address _account, uint256 _amount) internal virtual override {\n        require(totalSupply() + _amount <= cap(), \"ERC20Capped::You mint exceeds your cap\");\n        super._mint(_account, _amount);\n    }\n}"
    },
    "contracts/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../utils/Context.sol\";\n\ncontract ERC20 is IERC20, Context {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals = 18;\n\n    uint256 private _totalSupply;\n    \n    mapping(address => mapping(address => uint256)) private _allowances;\n    mapping(address => uint256) private _balances;\n    \n    constructor(string memory name_, string memory symbol_, uint8 decimals_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n    }\n     \n    function name() external view returns(string memory) {\n        return _name;\n    }\n    \n    function symbol() external view returns(string memory) {\n        return _symbol;\n    }\n\n    function decimals() external view returns (uint8) {\n        return _decimals;\n    }\n    \n    function totalSupply() public view override returns(uint256) {\n        return _totalSupply;\n    }\n     \n     \n    function balanceOf(address account) public view override returns (uint256) {\n         return _balances[account];\n    }\n\n   \n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n \n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];   \n    }\n\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"Ruin::Transfer amount exceeds allowance\");\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), currentAllowance - amount);\n        return true;\n    }\n\n\n    function _transfer(\n        address _sender, \n        address _recipient, \n        uint256 _amount\n    ) private {\n        _beforeTokenTransfer(_sender, _recipient, _amount);\n        \n        require(_recipient != address(0), \"Ruin::Address of recipient is ilegal\");\n        require(_sender != address(0), \"Ruin::Address of sender is ilegal\");\n        require(_amount <= _balances[_sender], \"Ruin::Transfer amount exceeds account balance\");\n        \n        _balances[_sender] -= _amount;\n        _balances[_recipient] += _amount;\n        \n        emit Transfer(_sender, _recipient, _amount);\n    }\n    \n    function _approve(\n        address _approver, \n        address _spender, \n        uint256 _amount\n    ) private {\n        require(_approver != address(0), \"Ruin::Address of approver is illegal\");\n        require(_spender != address(0), \"Ruin::Address of spender is illegal\");\n        \n        _allowances[_approver][_spender] = _amount;\n        \n        emit Approval(_approver, _spender, _amount);\n    }\n    \n    function _mint(address _receiver, uint256 _amount) internal virtual {\n        require(_receiver != address(0), \"Ruin::Address of receiver is illegal\");\n        \n        _totalSupply += _amount;\n        _balances[_receiver] += _amount;\n        \n        emit Transfer(address(0), _receiver, _amount);\n    }\n    \n    function _burn(address _account, uint256 _amount) internal virtual {\n        require(_account != address(0), \"Ruin::Address is illegal\"); \n        require(_balances[_account] >= _amount, \"Ruin::Burning amount exceeds account balance\");\n        \n        _totalSupply -= _amount;\n        _balances[_account] -= _amount;\n        \n        emit Transfer(_account, address(0), _amount);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual  {\n    }\n}"
    },
    "contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract Pausable {\n    bool private _paused;\n\n    event Paused(address account);\n    event UnPaused(address account);\n\n    constructor() {\n        _paused = false;\n    }\n\n    function _pause() internal virtual {\n        _paused = true;\n        emit Paused(msg.sender);\n    } \n\n    function _unpause() internal virtual {\n        _paused = false;\n        emit UnPaused(msg.sender);\n    }\n\n    function paused() public view virtual returns(bool) {\n        return _paused;\n    }\n\n    modifier whenPaused() {\n        require(paused(), \"Pausable::Contract is not paused!\");\n        _;\n    }\n\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable::Contract is already paused!\");\n        _;\n    }\n}"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ncontract Context {\n    function _msgSender() internal view returns(address) {\n        return msg.sender;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}